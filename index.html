<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>reveal.js</title>

		<link rel="stylesheet" href="dist/reset.css">
		<link rel="stylesheet" href="dist/reveal.css">
		<link rel="stylesheet" href="dist/theme/black.css">

		<link rel="stylesheet" href="https://unpkg.com/firacode@6.2.0/distr/fira_code.css">

		<!-- Theme used for syntax highlighted code -->
		<link rel="stylesheet" href="plugin/highlight/monokai.css">

		<style> 
			:root{
				--r-main-font: "Fira Code"
			}
		</style>



	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<img class="r-stretch" src="https://rustacean.net/assets/rustacean-orig-noshadow.png">
					<h1>
						Intro to Rust Lang
					</h1>
					<p style="color:rgb(0, 255, 220);">
						by James Garrard
					</p> 
				</section>
				<section>
					<h style="color: rgb(250,200,65);">
						Let's Get Started
					</h>
				</section>
				<section>
					<h style="color: rgb(220,160,220);">
						History & Design Constraints &lt;
					</h>
					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							What is Rust?
						</h1>
						<p style="color:rgb(0, 255, 220);">
							Initially developed in 2006 by Graydon Hoare, a Mozilla employee
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							What is Rust?
						</h1>
						<p style="color:rgb(0, 255, 220);">
							Rust was sponsored by Mozilla in 2009 and officially announced to the public on July 7, 2010 under a dual MIT and Apache 2.0 license
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							What is Rust?
						</h1>
						<p style="color:rgb(0, 255, 220);">
							Initially compiled in OCaml until 2011 when it was successfully bootstrapped to a self-hosting LLVM front end IR compiler written in Rust.
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							What is Rust?
						</h1>
						<p style="color:rgb(0, 255, 220);">
							Significant language changes occurred up until 2015 and the official Rust 1.0 release
						</p>
						<p style="color:rgb(0, 255, 220);">
							Currently version 1.64.0 as of the creation of this slideshow
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							What is Rust?
						</h1>
						<p style="color:rgb(0, 255, 220);">
							Rust was inspired by Alef, C#, C++, Cyclone, Erlang, Haskell, Limbo, Newsqueak, OCaml, Ruby, Scheme, Standard ML, and Swift
						</p>
						<p style="color:rgb(0, 255, 220);">
							And inspired Carbon, Crystal, Idris, Spark, Swift, Project Verona, Zig
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							What is Rust?
						</h1>
						<p style="color:rgb(0, 255, 220);">
							Swift and Rust took inspiration from each other during their development.
						</p>
						<p style="color:rgb(0, 255, 220);">
							Check out Chris Lattner's Homepage for more information on how he developed Swift and many other projects like the LLVM, Clang, & JITS at https://nondot.org/sabre/
						</p>
					</section>

      				<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Why was Rust Created?
						</h1>
						<p style="color: rgb(250,200,65);">
							Rust was developed as part of the Servo project
						</p>
						<p style="color: rgb(250,200,65);">
							After 2014 portions of Servo were incorporated into Gecko and dubbed Firefox Quantum
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Why was Rust Created?
						</h1>
						<p style="color: rgb(250,200,65);">
							During Covid layoffs and corporate restructuring at Mozilla, both Servo development and Rust development were passed off to the Linux foundation and Rust foundation respectively.
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Constraints
						</h1>
						<p style="color: rgb(250,200,65);" class="fragment fade-in-then-out">
							‚öπ Low level and high level
						</p>
						<p style="color: rgb(250,200,65);" class="fragment fade-in-then-out">
							‚öπ Able to run on any hardware that you would need a browser
						</p>
						<p style="color: rgb(250,200,65);" class="fragment fade-in-then-out">
							‚öπ Fast enough for web technologies and UX
						</p>
						<p style="color: rgb(250,200,65);" class="fragment fade-in-then-out">
							‚öπ Stable 
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Enter The Borrow Checker
						</h1>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Enter The Borrow Checker
						</h1>
						<p style="color:rgb(165, 210, 40);">
							A variable must be assigned a value before use
						</p>
						<p style="color:rgb(165, 210, 40);">
							there is no null
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Enter The Borrow Checker
						</h1>
						<p style="color:rgb(165, 210, 40);">
							Values can be passed between variables, but only one variable can own the data at a time unless the value is constant
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Enter The Borrow Checker
						</h1>
						<p style="color:rgb(165, 210, 40);">
							When the owner goes out of scope, the value will be dropped and shadowed
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Enter The Borrow Checker
						</h1>
						<p style="color:rgb(165, 210, 40);">
							You can have const, 'static, immutable, and mutable variables
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Enter The Borrow Checker
						</h1>
						<p style="color:rgb(165, 210, 40);">
							In functions you can 
						</p>
						<p style="color:rgb(165, 210, 40);" class="fragment fade-in-then-out">
							pass a value: x
						</p>
						<p style="color:rgb(165, 210, 40);" class="fragment fade-in-then-out">
							pass a reference: &x
						</p>
						<p style="color:rgb(165, 210, 40);" class="fragment fade-in-then-out">
							pass a mutable reference: &mut x
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Enter The Borrow Checker
						</h1>
						<p style="color:rgb(165, 210, 40);">
							References are pointers that are guaranteed to have values or "aligned"
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Stack, Heap, & RAII
						</h1>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Stack, Heap, & RAII
						</h1>
						<p style="color: rgb(220,160,220);">
							All primative types are placed onto the stack as the stack is faster and deallocates without pointers
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Stack, Heap, & RAII
						</h1>
						<p style="color: rgb(220,160,220);">
							"Resource Acquisition is Initialization"
						</p>
					</section>
					
					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Stack, Heap, & RAII
						</h1>
						<p style="color: rgb(220,160,220);">
							To place something on the heap it needs to be Box&lt;T&gt;
						</p>
						<p style="color: rgb(220,160,220);">
							This allows objects on the heap to inhert the drop trait destructor to ensure it is removed from memory when no longer in use 
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Stack, Heap, & RAII
						</h1>
						<p style="color: rgb(220,160,220);">
							Because variables are in charge of freeing their own resources, resources can only have one owner and must be moved between owners
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Stack, Heap, & RAII
						</h1>
						<p style="color: rgb(220,160,220);">
							This gives Rust its memory, concurrency, and thread safety baked into the design
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Stack, Heap, & RAII
						</h1>
						<pre data-id="code"><code data-line-numbers class="hlrust" data-trim>
							let mut x: u32 = 123;
						</code></pre>
					</section>
				</section>

				<section>
					<h style="color: rgb(250,200,65);">
						Language Features
					</h>

					<section data-markdown>
						<p style="color: rgb(255,88,88);" data-template>
							[Rust Book](https://doc.rust-lang.org/book/)
						</p>
					</section>

					<section data-markdown>
						<p style="color: rgb(255,88,88);" data-template>
							[Rust by Example](https://doc.rust-lang.org/rust-by-example/)
						</p>
					</section>

					<section data-markdown>
						<p style="color: rgb(255,88,88);" data-template>
							[Rust Online Editor](https://play.rust-lang.org/)
						</p>
					</section>
					
					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Operators
						</h1>
						
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Operators
						</h1>
						<p style="color:rgb(0, 255, 220);">
							They're mostly the same as C!
						</p>
						<p style="color:rgb(0, 255, 220);" class="fragment fade-in">
							Well, except for ++ & --
						</p>
						<p style="color:rgb(0, 255, 220);" class="fragment fade-in">
							Rust prefers the unambiguous x += 1;
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Operators
						</h1>
						<p style="color:rgb(0, 255, 220);">
							The syntax is very close to C & Swift
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Operators
						</h1>
						<p style="color:rgb(0, 255, 220);">
							Type can be inferred by the compiler most of the time
						</p>
						<pre class="fragment fade-in" data-id="code"><code class="hlrust" data-trim>
							let a: i32 = 5;
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Primative Types
						</h1>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Primative Types
						</h1>
						<p style="color:rgb(0, 255, 220);">
							<table>
								<thead>
								<tr><th>Length</th><th>Signed</th><th>Unsigned</th></tr>
								</thead>
								<tbody>
									<tr><th>8-bit</th><th>i8</th><th>u8</th></tr>
									<tr><td>16-bit</td><td>i16</td><td>u16</td></tr>
									<tr><td>32-bit</td><td>i32</td><td>u32</td></tr>
									<tr><td>64-bit</td><td>i64</td><td>u64</td></tr>
									<tr><td>128-bit</td><td>i128</td><td>u128</td></tr>
									<tr><td>arch</td><td>isize</td><td>usize</td></tr>
								</tbody>
							</table>
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Primative Types
						</h1>
						<table><thead><tr><th>Base</th><th>Example</th><th>Format</th></tr></thead>
							<tbody>
							<tr><td>Decimal</td><td><code>98_222</code></td><td><code>{}</code></td></tr>
							<tr><td>Hex</td><td><code>0xff</code></td><td><code>{:X|x}</code></td></tr>
							<tr><td>Octal</td><td><code>0o77</code></td><td><code>{:o}</code></td></tr>
							<tr><td>Binary</td><td><code>0b1111_0000</code></td><td><code>{:b}</code></td></tr>
							<tr><td>Byte (<code>u8</code> only)</td><td><code>b'A'</code></td></tr>
							</tbody>
						</table>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Primative Types
						</h1>
						<table>
							<thead><tr><th>Type</th><th>Keyword</th><th>Example</th><th>Size</th></tr></thead>
							<tbody>
								<tr><td>Float</td><td>f32 & f64</td><td>10.0</td><td>4B & 8B</td></tr>
								<tr><td>Character</td><td>char</td><td>üòä</td><td>Unicode Scalar Value(1:4B)</td></tr>
								<tr><td>Boolean</td><td>bool</td><td>false</td><td>1B</td></tr>
							</tbody>
						</table>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Primative Types
						</h1>
						<p  style="color:rgb(0, 255, 220);">
							You can cast primatives with 'as'
						</p>
					</section>


					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Printing/Formating
						</h1>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Printing/Formating
						</h1>
						<pre data-id="code"><code data-line-numbers class="hlrust" data-trim>
							let firstName = James;
							let lastName = Garrard;
							println!("My name is {} {}", firstName, lastName);
						</code></pre>
						<p class="fragment fade-in">
							> My name is James Garrard
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Printing/Formating
						</h1>
						<pre data-id="code"><code data-line-numbers class="hlrust" data-trim>
							let firstName = James;
							let lastName = Garrard;
							println!("My name is {1}, {0} {1}", firstName, lastName);
						</code></pre>
						<p class="fragment fade-in">
							> My name is Garrard, James Garrard
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Printing/Formating
						</h1>
						<pre data-id="code"><code data-line-numbers class="hlrust" data-trim>
							let firstName = James;
							let lastName = Garrard;
							println!("My name is {firstName} {lastName}");
						</code></pre>
						<p class="fragment fade-in">
							> My name is James Garrard
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Printing/Formating
						</h1>
						<pre data-id="code"><code data-line-numbers class="hlrust" data-trim>
							println!("My name is {firstName} {lastName}", 
							lastName = Garrard, 
							firstName = James);
						</code></pre>
						<p class="fragment fade-in">
							> My name is James Garrard
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Printing/Formating
						</h1>
						<p style="color: rgb(115,220,240);" data-markdown data-template>
							[Fill/Alignment](https://doc.rust-lang.org/std/fmt/)
						</p>
						<pre data-id="code"><code data-line-numbers class="hlrust" data-trim>
							let width: usize = 5;
							format!("{:[fill]&lt;width$}", x); 			// x----
							format!("{:[fill]^1$}", x, 5);				// --x--
							format!("{:[fill]&gt;width$}", x, width=x); // ----x
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Printing/Formating
						</h1>
						<p style="color: rgb(115,220,240);" data-markdown data-template>
							[Fill/Alignment](https://doc.rust-lang.org/std/fmt/)
						</p>
						<pre data-id="code"><code data-line-numbers class="hlrust" data-trim>
							format!("{:+}", 5); 	    // +5		    display sign
							format!("{:04}", -5); 		// -005			leading zeros
							format!("{:.1}", 0.05);		// 0.1			float weird rounding
							format!("{:?}", (1, 2));	// (1, 2)		structs to_string()
							format!("{:#?}", (1, 2));	// (\n1,\n2\n)	special
							format!("{:#010x}", 27);	// 0x0000001b   special
						</code></pre>
					</section>


					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Printing/Formating
						</h1>
						<pre data-id="code"><code class="hlrust" data-trim>
							format_string := text [ maybe_format text ] *
							maybe_format := '{' '{' | '}' '}' | format
							format := '{' [ argument ] [ ':' format_spec ] [ ws ] * '}'
							argument := integer | identifier

							format_spec := [[fill]align][sign]['#']['0'][width]['.' precision]type
							fill := character
							align := '&lt;' | '^' | '&gt;'
							sign := '+' | '-'
							width := count
							precision := count | '*'
							type := '' | '?' | 'x?' | 'X?' | identifier
							count := parameter | integer
							parameter := argument '$'
						</code></pre>
					</section>
      				
					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Tuples
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Tuples are fixed size & mixed type 
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let tup: (i32, f64, u8) = (500, 6.4, 1);
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Tuple fields are accessed with the '.' operator and position
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let first_value = tup.1;	//rust prefers snake_case

							fn area(dimensions: (u32, u32)) -> u32 {
								dimensions.0 * dimensions.1
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Tuple can be a unit
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let tup = ();	//‚ö†Ô∏èvery important!
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Tuple values can also be destuctured
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let (x, y, z) = tup;	//we'll talk more about this later

							let v: (i32, f64, u8) = (500, 6.4, 1);
							let x = v.0; // passed value 
							let y = v.1; // ownership
							let z = v.2;
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Arrays
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Arrays are fixed size & single type
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let a: [i32; 5] = [1, 2, 3, 4, 5];
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Arrays can be prefilled with a value
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let a = [3; 5];
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Array index elements
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let first = a[0];
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Array memory safety:
						</p>
						<p style="color: rgb(115,220,240);"> 
							Rust will intentionally panic if a index is out of bounds unlike C/++ and will report this on the backtrace 
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Slices
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Slices
						</p>
						<p style="color: rgb(115,220,240);"> 
							A fat reference to a contiguous compund type
						</p>
						<p style="color: rgb(115,220,240);">
							They can be used on Arrays, Strings, and Vectors
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Compound Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Slices themselves aren't owned because they are a reference, not a value, but the value of the reference itself is owned
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let sl = &s[0..5];
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Standard Types
						</h1>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Standard Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Strings literals are technically slices of 'static memory
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let s: str = "hello";
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Standard Types
						</h1>
						<p style="color: rgb(115,220,240);">
							String strings are box&lt;T&gt; on the heap and are useful for things like user input
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let mut s = String::from("hello");
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Standard Types
						</h1>
						<p style="color: rgb(115,220,240);">
							&str can be copied like all stack values, but String has to call the clone function like all heap values
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let y = x; //works for primatives as they have the copy trait
							let y = x.clone(); works for box&lt;T&gt; impl drop trait
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Standard Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Strings have all the ususally implemented functions in std like trim, split, etc, but watch out for .len() vs .char().count() as chars are USV
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Standard Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Vectors
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Standard Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Vectors
						</p>
						<p style="color: rgb(115,220,240);">
							Used identically to array syntax
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let v: Vec&lt;i32&gt; = Vec::new();
							let v: Vec&lt;i32&gt; = vec![];
							let v = vec![1, 2, 3, 4, 5];
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Standard Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Standard Modules
						</p>
						<p style="color: rgb(115,220,240);" class="fragment fade-in">
							ptr, str, vec, hash, hint, future, collections, boxed, clone, any, alloc, marker, io, slice, boxed, borrow, etc
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Structs
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Tuple
						</p>
						<p style="color: rgb(115,220,240);">
							Structs
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							struct Color(i32, i32, i32);

							fn lightness(color: &Color) -> i32 {
								color.0 + color.1 + color.2 / 3
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Regular
						</p>
						<p style="color: rgb(115,220,240);">
							Structs
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							struct thing {
								active: bool,
								username: String,
								email: String,
								sign_in_count: u64,
								key: value,
							}

							fn area(rectangle: &Rectangle) -> u32 {
								rectangle.width * rectangle.height
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Parameter Field init
						</p>
						<p style="color: rgb(115,220,240);">
							Structs
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							fn build_user(email: String, username: String) -> User {
								User {
									email: email,
									username: username,
									active: true,
									sign_in_count: 1,
								}
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Parameter Field init
						</p>
						<p style="color: rgb(115,220,240);">
							Structs
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							fn build_user(email: String, username: String) -> User {
								User {
									email,
									username,
									active: true,
									sign_in_count: 1,
								}
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Unit-like
						</p>
						<p style="color: rgb(115,220,240);">
							Structs
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							struct Abstract; //like ()
							/*Can still implement traits
							**And methods
							*/
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Assigning
						</p>
						<p style="color: rgb(115,220,240);">
							Structs
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let user2 = User {
								active: user1.active,
								username: user1.username,
								email: String::from("newemail@example.com"),
								..user1 // clone values from other struct
							};
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Lifetimes of
						</p>
						<p style="color: rgb(115,220,240);">
							Structs
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							struct User&lt;'a&gt; {
								active: bool,
								username: &'a str,
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Enums
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Enums
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							enum IpAddrKind {
								V4,
								V6,
							}
							let four = IpAddrKind::V4;
							let six = IpAddrKind::V6;
							fn route(ip_kind: IpAddrKind) {}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p  style="color: rgb(115,220,240);">
							In Structing
						</p>
						<p style="color: rgb(115,220,240);">
							Enums
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							enum IpAddr { // already in std!
								V4(u8, u8, u8, u8),
								V6(String),
							}
							let home = IpAddr::V4(127, 0, 0, 1);
							let loopback = IpAddr::V6(String::from("::1"));
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Enums
						</p>
						<p  style="color: rgb(115,220,240);">
							are essentially super structs
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							enum Message {
								Quit,
								Move { x: i32, y: i32 },
								Write(String),
								ChangeColor(i32, i32, i32),
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							User-defined Types
						</h1>
						<p style="color: rgb(115,220,240);">
							Conversions
						</p>
						<p  style="color: rgb(115,220,240);">
							are essentially super structs
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							type::from(T); //converts generic to type
							T.into(); // also to_string() and to_vec()
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Regular
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<pre data-id="code"><code class="hlrust" data-trim>
							fn fnName(arguments) -> return type {
								// code block body
								let x: i32 = 156;    
								// return x + 5;
								x + 5
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Inline
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<pre data-id="code"><code class="hlrust" data-trim>
							fn function(i: i32) -> i32 { i + 1 }
							let x = {let y = 6; y + 1}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Closure
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<pre data-id="code"><code class="hlrust" data-trim>
							|val| val + x
							let closure_annotated = |i: i32| -> i32 { i + 1 };
							let one = || 1;
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Closure
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<p style="color: rgb(250,200,65);">
							Closures are actually the inline implementation of FnOnce
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Closure
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<p style="color: rgb(250,200,65);">
							Closures are also an inline implementation of FnMut
						</p>
						<pre data-id="code"><code class="hlrust" data-trim></code>
							let mut count = 0;
							let mut inc = || {
								count += 1;
								println!("`count`: {}", count);
							};
							inc();
							inc();
							let _count_reborrowed = &mut count; 
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Closure
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<p style="color: rgb(250,200,65);">
							Closures are also an inline implementation of Fn
						</p>
						<pre data-id="code"><code class="hlrust" data-trim></code>
							let one = || 1;
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							FnOnce
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<pre data-id="code"><code class="hlrust" data-trim>
							fn consume_with_relish<F>(func: F)
								where F: FnOnce() -> String
							{
								println!("Consumed: {}", func());
								println!("Delicious!");
							}
							let x = String::from("x");
							let consume_and_return_x = move || x;
							consume_with_relish(consume_and_return_x);
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							FnMut
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<pre data-id="code"><code class="hlrust" data-trim>
							fn do_twice<F>(mut func: F)
								where F: FnMut()
							{
								func();
								func();
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Fn
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<p>
							Fn ‚äÇ FnMut ‚äÇ FnOnce
						</p>
						<p style="color: rgb(250,200,65);">
							Fn will take immutable references or literals
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Impl
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<p style="color: rgb(250,200,65);">
							We'll see more uses of impl during the OOP section
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							fn thing_returning_closure() -> impl Fn(i32) -> bool {
								println!("here's a closure for you!");
								|x: i32| x % 3 == 0
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Higher Order
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<p style="color: rgb(250,200,65);">
							Implementation of funtional design
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let sum_of_squared_odd_numbers: u32 =
							(0..)
							.map(|n| n * n)
							.take_while(|&n_squared| n_squared < upper)
							.filter(|&n_squared| is_odd(n_squared))
							.sum();
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Diverging
						</h1>
						<h1 style="color: rgb(255,88,88);">
							Functions
						</h1>
						<p style="color: rgb(250,200,65);">
							Diverging functions would return the empty type '!'
						</p>
						<p style="color: rgb(250,200,65);">
							This is used in loops, matching, and other control flow
						</p>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Control Flow
						</h1>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Control Flow
						</h1>
						<p style="color: rgb(255,88,88);">
							Code block:
						</p>
						<pre data-id="code" class="fragment fade-in-then-out"><code class="hlrust" data-trim>
							{}
						</code></pre>
						<pre data-id="code" class="fragment fade-in-then-out"><code class="hlrust" data-trim>
							{x} // returns x
						</code></pre>
						<pre data-id="code" class="fragment fade-in-then-out"><code class="hlrust" data-trim>
							{x;} // returns ()
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Control Flow
						</h1>
						<p style="color: rgb(255,88,88);">
							If/else:
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							if true {
								x = 6;
							}
							else if {
								x = 5;
							}
							else {
								x = 4;
							}
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Control Flow
						</h1>
						<p style="color: rgb(255,88,88);">
							If/else:
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let x = if true {let x = 6; x} else {7};
						</code></pre>
					</section>

					<section data-auto-animate>
						<h1 style="color: rgb(250,200,65);">
							Control Flow
						</h1>
						<p style="color: rgb(255,88,88);">
							Match:
						</p>
						<pre data-id="code"><code class="hlrust" data-trim>
							let x = if true {let x = 6; x} else {7};
						</code></pre>
					</section>

				</section>

				<section>
					<h style="color: rgb(115,220,240);">
						Packages & Frameworks
					</h>
					<section>
						
					</section>

      				<section>Vertical Slide 2
					
					</section>

					<section>Vertical Slide 3

					</section>
				</section>
			</div>
		</div>

		<script src="dist/reveal.js"></script>
		<script src="plugin/notes/notes.js"></script>
		<script src="plugin/markdown/markdown.js"></script>
		<script src="plugin/highlight/highlight.js"></script>
		<script>
			// More info about initialization & config:
			// - https://revealjs.com/initialization/
			// - https://revealjs.com/config/
			Reveal.initialize({
				hash: true,

				// Learn about plugins: https://revealjs.com/plugins/
				plugins: [ RevealMarkdown, RevealHighlight, RevealNotes ]
			});
		</script>
	</body>
</html>
